# مبانی Threading و Tasks (سطح مبتدی)

برای تسلط به مفاهیم پیشرفته و فنی مربوط به `Threading` و `Task` در `C#` و `.NET`، ابتدا باید اصول پایه‌ای را بشناسید و سپس به تدریج به مفاهیم پیشرفته‌تر و بهترین روش‌های استفاده از این تکنیک‌ها در نسخه‌های جدید `C# 13` و `.NET 10` بپردازیم. در اینجا، این مفاهیم به طور دقیق توضیح داده شده‌اند:

## 1. مبانی Threading (مفهوم و استفاده از نخ‌ها)

### 1.1 نخ (Thread) چیست؟

یک نخ، واحدی از پردازش است که می‌تواند کدهای اجرایی را در برنامه اجرا کند. هر نخ یک مسیر مستقل از سایر نخ‌ها دارد و به صورت موازی یا همزمان با نخ‌های دیگر عمل می‌کند. در `C#`، کلاس `Thread` برای کار با نخ‌ها استفاده می‌شود.

### 1.2 ایجاد و شروع نخ‌ها با استفاده از کلاس Thread

برای ایجاد و شروع یک نخ، از کلاس `Thread` استفاده می‌کنیم. به طور معمول از یک `delegate` یا یک متد برای تعیین کارهایی که باید در نخ انجام شوند استفاده می‌شود.

```csharp
Thread thread = new Thread(MyMethod);
thread.Start();
```

در اینجا، `MyMethod` متدی است که قرار است در نخ جدید اجرا شود.

### 1.3 همگام‌سازی نخ‌ها با استفاده از lock، Monitor و Mutex

وقتی که چندین نخ به یک منبع مشترک (مثل متغیر یا داده) دسترسی پیدا می‌کنند، ممکن است رقابت کنند. این رقابت می‌تواند باعث دستکاری نادرست داده‌ها شود، به همین دلیل نیاز به همگام‌سازی برای مدیریت دسترسی به منابع مشترک داریم. در اینجا هر یک از ابزارهای همگام‌سازی چگونه عمل می‌کنند را توضیح می‌دهم.

#### 1.3.1 کلید واژه `lock` (که در حقیقت یک Wrapper برای کلاس `Monitor` است)

کلیدواژه `lock` ساده‌ترین روش برای جلوگیری از رقابت نخ‌ها بر سر منابع مشترک است. وقتی یک نخ وارد بلاک `lock` می‌شود، سایر نخ‌ها نمی‌توانند وارد آن قسمت شوند تا زمانی که نخ اولی آن بخش را ترک کند. این ویژگی به صورت خودکار قفل را گرفته و آزاد می‌کند.

**چطور عمل می‌کند؟**

- وقتی یک نخ وارد بخش کدی که با `lock` محافظت شده می‌شود، `lock` یک قفل (`mutex`) داخلی می‌سازد که فقط به همان نخ اختصاص دارد.
- سایر نخ‌ها که وارد این بخش می‌شوند باید منتظر بمانند تا نخ اولی قفل را آزاد کند.

```csharp
object lockObject = new object();
lock (lockObject)
{
    // Critical section code
}
```

**تأثیرات:**

- وقتی یک نخ در حال اجرای کد درون `lock` است، سایر نخ‌ها نمی‌توانند به آن قسمت دسترسی پیدا کنند و باید منتظر بمانند.
- این باعث می‌شود که در برنامه‌های چندنخی داده‌ها به صورت امن و بدون تداخل از سوی نخ‌ها مدیریت شوند.

#### 1.3.2 کلاس `Monitor`

کلاس `Monitor` دقیقاً همان کاری را می‌کند که `lock` انجام می‌دهد، با این تفاوت که کنترل بیشتری روی آن داریم. `Monitor` این امکان را می‌دهد که به صورت دستی قفل را بگیریم و آن را آزاد کنیم.

**چطور عمل می‌کند؟**

- برای گرفتن قفل، از متد `Monitor.Enter()` استفاده می‌کنیم و برای آزاد کردن قفل از `Monitor.Exit()`.
- در صورتی که چندین نخ بخواهند به یک منبع دسترسی پیدا کنند، فقط نخ‌ای که قفل را گرفته قادر به دسترسی به منبع خواهد بود.

```csharp
object lockObject = new object();
Monitor.Enter(lockObject);
try
{
    // Critical section code
}
finally
{
    Monitor.Exit(lockObject);  // Always release lock
}
```

**تأثیرات:**

- نخ‌ها باید از `Monitor.Enter` و `Monitor.Exit` برای گرفتن و آزاد کردن قفل استفاده کنند.
- در صورتی که یک نخ قفل را نگیرد، سایر نخ‌ها نمی‌توانند به منبع دسترسی پیدا کنند.
- کلاس `Monitor` این امکان را می‌دهد که از ویژگی‌های دیگری مثل `wait` و `pulse` برای هماهنگ‌سازی دقیق‌تر نخ‌ها استفاده کنیم، که در موارد خاص مانند صف‌های پیام یا درخواست‌های پیچیده‌تر مفید است.

#### 1.3.3 کلاس `Mutex`

کلاس `Mutex` مشابه `lock` است ولی با این تفاوت که می‌تواند در سطح فرآیند نیز استفاده شود. یعنی، اگر دو برنامه یا دو فرآیند مختلف به یک منبع دسترسی داشته باشند، می‌توانند از `Mutex` برای همگام‌سازی استفاده کنند. در حالی که `lock` و `Monitor` معمولاً در سطح نخ‌ها عمل می‌کنند.

**چطور عمل می‌کند؟**

- وقتی یک نخ نیاز دارد که قفل را بگیرد، از `Mutex.WaitOne()` استفاده می‌کند.
- وقتی که نخ کارش تمام شد، باید با استفاده از `Mutex.ReleaseMutex()` قفل را آزاد کند.

```csharp
Mutex mutex = new Mutex();
mutex.WaitOne();  // Wait until the mutex is available
try
{
    // Critical section code
}
finally
{
    mutex.ReleaseMutex();  // Always release mutex
}
```

**تأثیرات:**

- کلاس `Mutex` از قفل‌های بین نخ‌ها در فرآیندهای مختلف پشتیبانی می‌کند.
- معمولاً وقتی که بخواهید همگام‌سازی در سطح بالاتر از نخ‌ها (مثل میان برنامه‌ها یا فرآیندهای مختلف) انجام دهید، از `Mutex` استفاده می‌کنید.
- همچنین `Mutex` بیشتر منابع سیستم را نسبت به `lock` مصرف می‌کند، بنابراین به طور معمول از `Mutex` در سناریوهای خاص استفاده می‌شود.

#### مقایسه اثرات و تفاوت‌ها

- کلیدواژه **`lock`**: مناسب‌ترین گزینه برای همگام‌سازی نخ‌ها در داخل یک فرآیند است و پیاده‌سازی ساده‌ای دارد.

- کلاس **`Monitor`**: مانند `lock` است ولی به شما امکان کنترل بیشتری روی قفل‌ها می‌دهد. برای موارد پیچیده‌تر مانند مدیریت منتظر ماندن نخ‌ها یا ارسال سیگنال به نخ‌ها می‌توان از آن استفاده کرد.

- کلاس **`Mutex`**: وقتی که نیاز به همگام‌سازی در سطح فرآیندهای مختلف دارید (یعنی وقتی که می‌خواهید نخ‌ها در برنامه‌های مختلف به منبع مشترک دسترسی پیدا کنند)، استفاده از `Mutex` مناسب‌تر است.

#### نکات کلیدی

- همگام‌سازی نخ‌ها می‌تواند عملکرد برنامه شما را کاهش دهد (زمانی که نخ‌ها باید منتظر بمانند تا قفل‌ها آزاد شوند).

- مسیله `Race Conditions` زمانی رخ می‌دهند که چندین نخ همزمان سعی دارند به داده‌ها دسترسی پیدا کنند و این می‌تواند منجر به خطاهای عجیب و نامفهوم شود. به همین دلیل استفاده از ابزارهای همگام‌سازی بسیار ضروری است.

- همیشه باید از finally برای آزاد کردن قفل‌ها استفاده کنید تا در صورت بروز هرگونه خطا، قفل به درستی آزاد شود.

### 1.4 چرخه حیات نخ (Creation, Execution, Termination)

هر نخ در طول عمر خود سه مرحله اصلی را طی می‌کند: ایجاد، اجرا و اتمام. درک این مراحل برای مدیریت صحیح نخ‌ها و جلوگیری از مشکلات رایج در برنامه‌نویسی چندنخی ضروری است.

#### 1.4.1 مرحله ایجاد (Creation)

در این مرحله، نمونه‌ای از کلاس `Thread` ساخته می‌شود و متدی که باید اجرا شود به آن اختصاص داده می‌شود. نخ در این مرحله هنوز فعال نیست و در حالت آماده‌باش قرار دارد.

```csharp
Thread thread = new Thread(MyMethod);
// در این نقطه، نخ هنوز اجرا نشده است
```

**ویژگی‌های مرحله ایجاد:**

- نخ فقط تعریف شده و هنوز هیچ کدی اجرا نکرده است
- منابع اولیه به نخ اختصاص داده می‌شود اما هنوز از CPU استفاده نمی‌کند
- برای شروع اجرا باید متد `Start()` فراخوانی شود

#### 1.4.2 مرحله اجرا (Execution)

پس از فراخوانی `Start()`، نخ وارد مرحله اجرا می‌شود و کد تعیین شده را به صورت موازی با سایر نخ‌ها اجرا می‌کند.

```csharp
thread.Start();  // نخ اکنون شروع به اجرا می‌کند
```

**ویژگی‌های مرحله اجرا:**

- نخ به طور مستقل و موازی با نخ اصلی و سایر نخ‌ها اجرا می‌شود
- سیستم عامل زمان CPU را بین نخ‌های مختلف تقسیم می‌کند
- نخ می‌تواند به منابع مشترک دسترسی پیدا کند (نیاز به همگام‌سازی)
- نخ ممکن است به دلایل مختلف مسدود شود:
  - منتظر ماندن برای قفل (`lock`, `Monitor`)
  - منتظر ماندن برای داده‌ها (I/O operations)
  - منتظر ماندن برای سیگنال از نخ دیگر

**نکته مهم:** در این مرحله است که نیاز به همگام‌سازی با استفاده از `lock`، `Monitor` یا `Mutex` احساس می‌شود تا از دسترسی همزمان به منابع مشترک جلوگیری شود.

#### 1.4.3 مرحله اتمام (Termination)

نخ زمانی به مرحله اتمام می‌رسد که کد تعیین شده به طور کامل اجرا شده باشد یا به دلیل خطا متوقف شده باشد.

**روش‌های اتمام نخ:**

1. **اتمام طبیعی:** کد متد به پایان می‌رسد و نخ به طور خودکار خاتمه می‌یابد
2. **اتمام با استثنا:** در صورت بروز خطا، نخ متوقف می‌شود
3. **اتمام اجباری:** استفاده از `Thread.Abort()` (منسوخ شده و توصیه نمی‌شود)

**تأثیرات مرحله اتمام:**

- تمام منابع اختصاص داده شده به نخ آزاد می‌شوند
- نخ دیگر قابل استفاده نیست و نمی‌توان دوباره `Start()` را روی آن فراخوانی کرد
- اگر نخ به دلیل خطا متوقف شده باشد، ممکن است منابع مشترک در وضعیت نامعتبر باقی بمانند

#### 1.4.4 مدیریت هماهنگی نخ‌ها با Join()

متد `Join()` یکی از ابزارهای مهم برای هماهنگی بین نخ‌ها است. این متد باعث می‌شود که نخ فعلی منتظر بماند تا نخ دیگری به طور کامل به پایان برسد.

**کاربرد Join():**

```csharp
Thread thread = new Thread(MyMethod);
thread.Start();

// نخ اصلی منتظر می‌ماند تا thread به پایان برسد
thread.Join();

// این کد فقط پس از اتمام thread اجرا می‌شود
Console.WriteLine("نخ به پایان رسید");
```

**تأثیرات و کاربردهای Join():**

1. **اطمینان از اتمام کار:** قبل از استفاده از نتایج یک نخ، می‌توانید از `Join()` استفاده کنید تا مطمئن شوید کار به پایان رسیده است

2. **هماهنگی ترتیبی:** اگر نیاز دارید چندین نخ به ترتیب خاصی اجرا شوند، می‌توانید از `Join()` برای کنترل ترتیب استفاده کنید

3. **مدیریت منابع:** قبل از آزاد کردن منابع مشترک یا بستن برنامه، می‌توانید با `Join()` مطمئن شوید که تمام نخ‌ها به پایان رسیده‌اند

4. **استفاده از Join با زمان انتظار:** می‌توانید حداکثر زمان انتظار را مشخص کنید:

```csharp
if (thread.Join(TimeSpan.FromSeconds(5)))
{
    // نخ در زمان مشخص شده به پایان رسید
}
else
{
    // نخ در زمان مشخص شده به پایان نرسید
    // ممکن است نیاز به اقدام دیگری باشد
}
```

**نکته مهم:** استفاده از `Join()` باعث می‌شود نخ فعلی مسدود شود و منتظر بماند. اگر نخ هدف هرگز به پایان نرسد، نخ فعلی برای همیشه مسدود می‌ماند. بنابراین بهتر است از نسخه‌ای با زمان انتظار استفاده کنید.

#### 1.4.5 سناریوی پیچیده: هماهنگی چندین نخ با Join()

برای درک بهتر نحوه کار `Join()` در سناریوهای پیچیده، یک مثال عملی با سه نخ (نخ اصلی، نخ فرعی 1 و نخ فرعی 2) را بررسی می‌کنیم:

**سناریو:** نخ فرعی 1 منتظر اتمام نخ فرعی 2 است، و نخ اصلی ابتدا منتظر اتمام نخ فرعی 2 و سپس منتظر اتمام نخ فرعی 1 است.

```csharp
static void Main()
{
    Console.WriteLine("نخ اصلی شروع شد");
    
    // ایجاد نخ فرعی 2
    Thread thread2 = new Thread(() => {
        Console.WriteLine("نخ فرعی 2 شروع شد");
        Thread.Sleep(2000); // شبیه‌سازی کار
        Console.WriteLine("نخ فرعی 2 به پایان رسید");
    });
    
    // ایجاد نخ فرعی 1 که منتظر نخ فرعی 2 می‌ماند
    Thread thread1 = new Thread(() => {
        Console.WriteLine("نخ فرعی 1 شروع شد");
        
        // نخ فرعی 1 منتظر اتمام نخ فرعی 2 می‌ماند
        thread2.Join();
        Console.WriteLine("نخ فرعی 1: نخ فرعی 2 به پایان رسید، ادامه می‌دهم");
        
        Thread.Sleep(1000); // کار اضافی نخ فرعی 1
        Console.WriteLine("نخ فرعی 1 به پایان رسید");
    });
    
    // شروع هر دو نخ
    thread2.Start();
    thread1.Start();
    
    // نخ اصلی منتظر اتمام نخ فرعی 2 می‌ماند
    thread2.Join();
    Console.WriteLine("نخ اصلی: نخ فرعی 2 به پایان رسید");
    
    // سپس نخ اصلی منتظر اتمام نخ فرعی 1 می‌ماند
    thread1.Join();
    Console.WriteLine("نخ اصلی: نخ فرعی 1 به پایان رسید");
    Console.WriteLine("نخ اصلی به پایان رسید");
}
```

**خروجی احتمالی:**

```
نخ اصلی شروع شد
نخ فرعی 2 شروع شد
نخ فرعی 1 شروع شد
(2 ثانیه انتظار)
نخ فرعی 2 به پایان رسید
نخ فرعی 1: نخ فرعی 2 به پایان رسید، ادامه می‌دهم
نخ اصلی: نخ فرعی 2 به پایان رسید
(1 ثانیه انتظار)
نخ فرعی 1 به پایان رسید
نخ اصلی: نخ فرعی 1 به پایان رسید
نخ اصلی به پایان رسید
```

**نکات مهم این سناریو:**

1. **عبارت Join() می‌تواند از چندین نخ فراخوانی شود:** هم نخ اصلی و هم نخ فرعی 1 می‌توانند روی نخ فرعی 2 `Join()` فراخوانی کنند. این کاملاً مجاز است و هر دو نخ منتظر می‌مانند تا نخ فرعی 2 به پایان برسد.

2. **ترتیب Join() مهم است:** در این مثال، نخ اصلی ابتدا منتظر نخ فرعی 2 می‌ماند و سپس منتظر نخ فرعی 1. این ترتیب تضمین می‌کند که نخ اصلی می‌داند نخ فرعی 2 تمام شده است قبل از اینکه منتظر نخ فرعی 1 بماند.

3. **عبارت Join() در نخ‌های فرعی:** نخ فرعی 1 نیز می‌تواند از `Join()` استفاده کند تا منتظر نخ فرعی 2 بماند. این نشان می‌دهد که `Join()` فقط محدود به نخ اصلی نیست و هر نخی می‌تواند منتظر نخ دیگری بماند.

4. **زمان‌بندی و هماهنگی:** در این سناریو، نخ فرعی 1 نمی‌تواند کار خود را کامل کند تا زمانی که نخ فرعی 2 تمام شود. این یک وابستگی ترتیبی ایجاد می‌کند که می‌تواند برای هماهنگی کارهای مرتبط مفید باشد.

5. **مزیت استفاده از Join() در نخ‌های فرعی:** اگر نخ فرعی 1 نیاز به نتایج یا وضعیت نخ فرعی 2 دارد، استفاده از `Join()` در داخل نخ فرعی 1 تضمین می‌کند که کار نخ فرعی 2 قبل از ادامه کار نخ فرعی 1 تمام شده است.

**نکته احتیاطی:** در این سناریو، اگر نخ فرعی 2 هرگز به پایان نرسد، هم نخ اصلی و هم نخ فرعی 1 برای همیشه مسدود می‌مانند. برای جلوگیری از این مشکل، بهتر است از نسخه‌ای با زمان انتظار استفاده کنید:

```csharp
// در نخ فرعی 1
if (thread2.Join(TimeSpan.FromSeconds(5)))
{
    Console.WriteLine("نخ فرعی 1: نخ فرعی 2 به پایان رسید");
}
else
{
    Console.WriteLine("نخ فرعی 1: نخ فرعی 2 در زمان مشخص شده به پایان نرسید");
    // تصمیم‌گیری برای ادامه یا توقف
}
```

#### 1.4.6 نمودار چرخه حیات و انتقال بین مراحل

```
ایجاد (Creation)
    ↓
    Start()
    ↓
اجرا (Execution) ←→ [مسدود شده] ←→ [اجرا]
    ↓
    (کد به پایان می‌رسد یا خطا رخ می‌دهد)
    ↓
اتمام (Termination)
```

**نکات کلیدی:**

- انتقال از ایجاد به اجرا فقط با `Start()` امکان‌پذیر است
- یک نخ نمی‌تواند مستقیماً از ایجاد به اتمام برود
- نخ در مرحله اجرا می‌تواند چندین بار مسدود و آزاد شود
- پس از اتمام، نخ دیگر قابل استفاده نیست و باید نمونه جدیدی ایجاد شود

### 1.5 استفاده از Thread.Sleep() و Thread.Join()

**`Thread.Sleep()`**: متد `Thread.Sleep()` به نخ فعلی دستور می‌دهد که به مدت زمان معین منتظر بماند.

```csharp
Thread.Sleep(1000); // Sleep for 1 second
```

**`Thread.Join()`**: این متد منتظر می‌ماند تا نخ دیگری اجرا شود و سپس ادامه دهد.

```csharp
thread.Join(); // Waits for thread to finish
```

## 2. مبانی Tasks (مفهوم و استفاده از تسک‌ها)

### 2.1 مقدمه‌ای بر Task و `Task<T>` در .NET

کلاس `Task` نمایانگر یک واحد کار غیرهمزمان است که ممکن است نتیجه‌ای تولید کند. `Task` برای پیاده‌سازی برنامه‌های ناهمزمان و غیرهمزمان به کار می‌رود.

### 2.2 استفاده از Task.Run() و Task.Factory.StartNew()

**`Task.Run()`**: متد `Run()` برای اجرای یک تسک غیرهمزمان استفاده می‌شود.

```csharp
Task task = Task.Run(() => SomeMethod());
```

**`Task.Factory.StartNew()`**: روش قدیمی‌تری برای شروع تسک است که به صورت پیش‌فرض در یک نخ جدید اجرا می‌شود.

```csharp
Task task = Task.Factory.StartNew(() => SomeMethod());
```

### 2.3 مفهوم Task Scheduler

مدیر تسک، مسئول تعیین زمان‌بندی و انتخاب نخ‌های مناسب برای اجرای تسک‌ها است. در صورتی که تعداد زیادی تسک همزمان اجرا شود، مدیر تسک باید تصمیم بگیرد که کدام تسک‌ها باید اولویت داشته باشند.

### 2.4 برنامه‌نویسی ناهمزمان با async و await

در `C#`، برای نوشتن برنامه‌های غیرهمزمان از کلمات کلیدی `async` و `await` استفاده می‌کنیم:

```csharp
public async Task MyMethodAsync() {
    await Task.Delay(1000); // Non-blocking delay
}
```

کلمه کلیدی `await` اجازه می‌دهد که متد تا اتمام تسک منتظر بماند بدون اینکه نخ اصلی را مسدود کند.

### 2.5 درک Task.WhenAll() و Task.WhenAny()

**`Task.WhenAll()`**: زمانی که می‌خواهیم چند تسک را به طور همزمان اجرا کنیم و منتظر اتمام همه آن‌ها باشیم.

```csharp
await Task.WhenAll(task1, task2);
```

**`Task.WhenAny()`**: زمانی که می‌خواهیم تا پایان اولین تسکی که به اتمام می‌رسد منتظر بمانیم.

```csharp
await Task.WhenAny(task1, task2);
```

## 3. مقایسه Threading و Tasks

### 3.1 تفاوت بین نخ‌ها و تسک‌ها

- **نخ‌ها**: یک واحد پردازشی هستند که به طور همزمان در یک برنامه اجرا می‌شوند و می‌توانند به صورت مستقیم با سیستم عامل ارتباط برقرار کنند.

- **تسک‌ها**: نمایانگر واحدهای کار در سطح بالاتر هستند که بر اساس نخ‌ها اجرا می‌شوند، ولی کار کردن با تسک‌ها برای مدیریت بهتر منابع و پیاده‌سازی برنامه‌های غیرهمزمان و بهینه‌تر مناسب‌تر است.

### 3.2 کی از نخ‌ها استفاده کنیم و کی از تسک‌ها؟

- از نخ‌ها زمانی استفاده کنید که نیاز به پردازش موازی با کنترل دقیق و زمان‌بندی دارید.

- از تسک‌ها برای اجرای برنامه‌های غیرهمزمان و بهینه استفاده کنید، مخصوصاً زمانی که می‌خواهید به صورت همزمان تعداد زیادی عملیات انجام دهید بدون اینکه منابع سیستم را به طور غیرضروری مصرف کنید.

## نکات پیشرفته و به‌روز شده در C# 13 و .NET 10

در `C# 13` و `.NET 10`، استفاده از `ValueTask` به جای `Task` در موقعیت‌هایی که نیاز به بازگشت سریع نتیجه داریم، بهینه‌تر شده است. این نوع تسک به شما کمک می‌کند تا از تخصیص حافظه اضافی جلوگیری کنید.

بهبودهایی در مدیریت نخ‌ها و `Task Scheduler` به وجود آمده که به برنامه‌نویسان اجازه می‌دهد برنامه‌های غیرهمزمان بهینه‌تری ایجاد کنند.

همچنین، در `.NET 10` امکانات جدیدی برای `Parallel Programming` و `Dataflow` فراهم شده که موجب تسهیل در پردازش داده‌ها به طور همزمان و موازی شده است.
