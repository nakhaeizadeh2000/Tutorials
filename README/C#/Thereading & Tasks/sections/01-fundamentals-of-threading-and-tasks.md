# مبانی Threading و Tasks (سطح مبتدی)

## فهرست مطالب

### بخش 1: مبانی Threading
- [1.1 نخ (Thread) چیست؟](#11-نخ-thread-چیست)
- [1.2 ایجاد و شروع نخ‌ها با استفاده از کلاس Thread](#12-ایجاد-و-شروع-نخها-با-استفاده-از-کلاس-thread)
- [1.3 همگام‌سازی نخ‌ها با استفاده از lock، Monitor و Mutex](#13-همگامسازی-synchronization-نخها-با-استفاده-از-lock-monitor-و-mutex)
- [1.4 چرخه حیات نخ](#14-چرخه-حیات-نخ-creation-execution-termination)
- [1.5 استفاده از Thread.Sleep() و Thread.Join()](#15-استفاده-از-threadsleep-و-threadjoin)

### بخش 2: مبانی Tasks
- [2.1 مقدمه‌ای بر Task و Task&lt;T&gt; در .NET](#21-مقدمهای-بر-task-و-taskt-در-net)
- [2.2 استفاده از Task.Run() و Task.Factory.StartNew()](#22-استفاده-از-taskrun-و-taskfactorystartnew)
- [2.3 مفهوم Task Scheduler (مدیر تسک)](#23-مفهوم-task-scheduler-مدیر-تسک)
- [2.4 برنامه‌نویسی ناهمزمان با async و await](#24-برنامهنویسی-ناهمزمان-با-async-و-await)
- [2.5 درک Task.WhenAll() و Task.WhenAny()](#25-درک-taskwhenall-و-taskwhenany)

### بخش 3: مقایسه Threading و Tasks
- [3.1 تفاوت بین نخ‌ها و تسک‌ها](#31-تفاوت-بین-نخها-و-تسکها)
- [3.2 کی از نخ‌ها استفاده کنیم و کی از تسک‌ها؟](#32-کی-از-نخها-استفاده-کنیم-و-کی-از-تسکها)
- [3.3 تفاوت Parallel (موازی) و Concurrent (همزمان)](#33-تفاوت-parallel-موازی-و-concurrent-همزمان)

### بخش 4: نکات پیشرفته
- [1. استفاده از ValueTask به جای Task برای بهینه‌سازی عملکرد](#1-استفاده-از-valuetask-به-جای-task-برای-بهینهسازی-عملکرد)
- [2. بهبودهای مدیریت نخ‌ها و Task Scheduler در .NET 10](#2-بهبودهای-مدیریت-نخها-و-task-scheduler-در-net-10)
- [3. بهبود در برنامه‌نویسی موازی و داده‌های موازی (Dataflow)](#3-بهبود-در-برنامهنویسی-موازی-parallel-programming-و-دادههای-موازی-dataflow)

---

برای تسلط به مفاهیم پیشرفته و فنی مربوط به `Threading` و `Task` در `C#` و `.NET`، ابتدا باید اصول پایه‌ای را بشناسید و سپس به تدریج به مفاهیم پیشرفته‌تر و بهترین روش‌های استفاده از این تکنیک‌ها در نسخه‌های جدید `C# 13` و `.NET 10` بپردازیم. در اینجا، این مفاهیم به طور دقیق توضیح داده شده‌اند:

## 1. مبانی Threading (مفهوم و استفاده از نخ‌ها)

<a id="11-نخ-thread-چیست"></a>
### 1.1 نخ (Thread) چیست؟

یک نخ، واحدی از پردازش است که می‌تواند کدهای اجرایی را در برنامه اجرا کند. هر نخ یک مسیر مستقل از سایر نخ‌ها دارد و به صورت موازی (Parallel) یا همزمان (Concurrent) با نخ‌های دیگر عمل می‌کند. در `C#`، کلاس `Thread` برای کار با نخ‌ها استفاده می‌شود.

<a id="12-ایجاد-و-شروع-نخها-با-استفاده-از-کلاس-thread"></a>
### 1.2 ایجاد و شروع نخ‌ها با استفاده از کلاس Thread

برای ایجاد و شروع یک نخ، از کلاس `Thread` استفاده می‌کنیم. به طور معمول از یک `delegate` یا یک متد برای تعیین کارهایی که باید در نخ انجام شوند استفاده می‌شود.

```csharp
Thread thread = new Thread(MyMethod);
thread.Start();
```

در اینجا، `MyMethod` متدی است که قرار است در نخ جدید اجرا شود.

<a id="13-همگامسازی-synchronization-نخها-با-استفاده-از-lock-monitor-و-mutex"></a>
### 1.3 همگام‌سازی (Synchronization) نخ‌ها با استفاده از lock، Monitor و Mutex

وقتی که چندین نخ به یک منبع مشترک (مثل متغیر یا داده) دسترسی پیدا می‌کنند، ممکن است رقابت کنند. این رقابت می‌تواند باعث دستکاری نادرست داده‌ها شود، به همین دلیل نیاز به همگام‌سازی (Synchronization) برای مدیریت دسترسی به منابع مشترک داریم. در اینجا هر یک از ابزارهای همگام‌سازی چگونه عمل می‌کنند را توضیح می‌دهم.

#### 1.3.1 کلید واژه `lock` (که در حقیقت یک Wrapper برای کلاس `Monitor` است)

کلیدواژه `lock` ساده‌ترین روش برای جلوگیری از رقابت نخ‌ها بر سر منابع مشترک است. وقتی یک نخ وارد بلاک `lock` می‌شود، سایر نخ‌ها نمی‌توانند وارد آن قسمت شوند تا زمانی که نخ اولی آن بخش را ترک کند. این ویژگی به صورت خودکار قفل را گرفته و آزاد می‌کند.

**چطور عمل می‌کند؟**

- وقتی یک نخ وارد بخش کدی که با `lock` محافظت شده می‌شود، `lock` یک قفل (`mutex`) داخلی می‌سازد که فقط به همان نخ اختصاص دارد.
- سایر نخ‌ها که وارد این بخش می‌شوند باید منتظر بمانند تا نخ اولی قفل را آزاد کند.

```csharp
object lockObject = new object();
lock (lockObject)
{
    // Critical section code
}
```

**تأثیرات:**

- وقتی یک نخ در حال اجرای کد درون `lock` است، سایر نخ‌ها نمی‌توانند به آن قسمت دسترسی پیدا کنند و باید منتظر بمانند.
- این باعث می‌شود که در برنامه‌های چندنخی داده‌ها به صورت امن و بدون تداخل از سوی نخ‌ها مدیریت شوند.

#### 1.3.2 کلاس `Monitor`

کلاس `Monitor` دقیقاً همان کاری را می‌کند که `lock` انجام می‌دهد، با این تفاوت که کنترل بیشتری روی آن داریم. `Monitor` این امکان را می‌دهد که به صورت دستی قفل را بگیریم و آن را آزاد کنیم.

**چطور عمل می‌کند؟**

- برای گرفتن قفل، از متد `Monitor.Enter()` استفاده می‌کنیم و برای آزاد کردن قفل از `Monitor.Exit()`.
- در صورتی که چندین نخ بخواهند به یک منبع دسترسی پیدا کنند، فقط نخ‌ای که قفل را گرفته قادر به دسترسی به منبع خواهد بود.

```csharp
object lockObject = new object();
Monitor.Enter(lockObject);
try
{
    // Critical section code
}
finally
{
    Monitor.Exit(lockObject);  // Always release lock
}
```

**تأثیرات:**

- نخ‌ها باید از `Monitor.Enter` و `Monitor.Exit` برای گرفتن و آزاد کردن قفل استفاده کنند.
- در صورتی که یک نخ قفل را نگیرد، سایر نخ‌ها نمی‌توانند به منبع دسترسی پیدا کنند.
- کلاس `Monitor` این امکان را می‌دهد که از ویژگی‌های دیگری مثل `wait` و `pulse` برای هماهنگ‌سازی دقیق‌تر نخ‌ها استفاده کنیم، که در موارد خاص مانند صف‌های پیام یا درخواست‌های پیچیده‌تر مفید است.

#### 1.3.3 کلاس `Mutex`

کلاس `Mutex` مشابه `lock` است ولی با این تفاوت که می‌تواند در سطح فرآیند نیز استفاده شود. یعنی، اگر دو برنامه یا دو فرآیند مختلف به یک منبع دسترسی داشته باشند، می‌توانند از `Mutex` برای همگام‌سازی استفاده کنند. در حالی که `lock` و `Monitor` معمولاً در سطح نخ‌ها عمل می‌کنند.

**چطور عمل می‌کند؟**

- وقتی یک نخ نیاز دارد که قفل را بگیرد، از `Mutex.WaitOne()` استفاده می‌کند.
- وقتی که نخ کارش تمام شد، باید با استفاده از `Mutex.ReleaseMutex()` قفل را آزاد کند.

```csharp
Mutex mutex = new Mutex();
mutex.WaitOne();  // Wait until the mutex is available
try
{
    // Critical section code
}
finally
{
    mutex.ReleaseMutex();  // Always release mutex
}
```

**تأثیرات:**

- کلاس `Mutex` از قفل‌های بین نخ‌ها در فرآیندهای مختلف پشتیبانی می‌کند.
- معمولاً وقتی که بخواهید همگام‌سازی در سطح بالاتر از نخ‌ها (مثل میان برنامه‌ها یا فرآیندهای مختلف) انجام دهید، از `Mutex` استفاده می‌کنید.
- همچنین `Mutex` بیشتر منابع سیستم را نسبت به `lock` مصرف می‌کند، بنابراین به طور معمول از `Mutex` در سناریوهای خاص استفاده می‌شود.

#### مقایسه اثرات و تفاوت‌ها

- کلیدواژه **`lock`**: مناسب‌ترین گزینه برای همگام‌سازی نخ‌ها در داخل یک فرآیند است و پیاده‌سازی ساده‌ای دارد.

- کلاس **`Monitor`**: مانند `lock` است ولی به شما امکان کنترل بیشتری روی قفل‌ها می‌دهد. برای موارد پیچیده‌تر مانند مدیریت منتظر ماندن نخ‌ها یا ارسال سیگنال به نخ‌ها می‌توان از آن استفاده کرد.

- کلاس **`Mutex`**: وقتی که نیاز به همگام‌سازی در سطح فرآیندهای مختلف دارید (یعنی وقتی که می‌خواهید نخ‌ها در برنامه‌های مختلف به منبع مشترک دسترسی پیدا کنند)، استفاده از `Mutex` مناسب‌تر است.

#### نکات کلیدی

- همگام‌سازی نخ‌ها می‌تواند عملکرد برنامه شما را کاهش دهد (زمانی که نخ‌ها باید منتظر بمانند تا قفل‌ها آزاد شوند).

- مسیله Race Conditions (شرایط رقابتی) زمانی رخ می‌دهند که چندین نخ همزمان سعی دارند به داده‌ها دسترسی پیدا کنند و این می‌تواند منجر به خطاهای عجیب و نامفهوم شود. به همین دلیل استفاده از ابزارهای همگام‌سازی (Synchronization) بسیار ضروری است.

- همیشه باید از finally برای آزاد کردن قفل‌ها استفاده کنید تا در صورت بروز هرگونه خطا، قفل به درستی آزاد شود.

<a id="14-چرخه-حیات-نخ-creation-execution-termination"></a>
### 1.4 چرخه حیات نخ (Creation, Execution, Termination)

هر نخ در طول عمر خود سه مرحله اصلی را طی می‌کند: ایجاد، اجرا و اتمام. درک این مراحل برای مدیریت صحیح نخ‌ها و جلوگیری از مشکلات رایج در برنامه‌نویسی چندنخی ضروری است.

#### 1.4.1 مرحله ایجاد (Creation)

در این مرحله، نمونه‌ای از کلاس `Thread` ساخته می‌شود و متدی که باید اجرا شود به آن اختصاص داده می‌شود. نخ در این مرحله هنوز فعال نیست و در حالت آماده‌باش قرار دارد.

```csharp
Thread thread = new Thread(MyMethod);
// در این نقطه، نخ هنوز اجرا نشده است
```

**ویژگی‌های مرحله ایجاد:**

- نخ فقط تعریف شده و هنوز هیچ کدی اجرا نکرده است
- منابع اولیه به نخ اختصاص داده می‌شود اما هنوز از CPU استفاده نمی‌کند
- برای شروع اجرا باید متد `Start()` فراخوانی شود

#### 1.4.2 مرحله اجرا (Execution)

پس از فراخوانی `Start()`، نخ وارد مرحله اجرا می‌شود و کد تعیین شده را به صورت موازی (Parallel) با سایر نخ‌ها اجرا می‌کند.

```csharp
thread.Start();  // نخ اکنون شروع به اجرا می‌کند
```

**ویژگی‌های مرحله اجرا:**

- نخ به طور مستقل و موازی (Parallel) با نخ اصلی و سایر نخ‌ها اجرا می‌شود
- سیستم عامل زمان CPU را بین نخ‌های مختلف تقسیم می‌کند
- نخ می‌تواند به منابع مشترک دسترسی پیدا کند (نیاز به همگام‌سازی (Synchronization))
- نخ ممکن است به دلایل مختلف مسدود (Blocked) شود:
  - منتظر ماندن برای قفل (`lock`, `Monitor`)
  - منتظر ماندن برای داده‌ها (عملیات I/O)
  - منتظر ماندن برای سیگنال از نخ دیگر

**نکته مهم:** در این مرحله است که نیاز به همگام‌سازی (Synchronization) با استفاده از `lock`، `Monitor` یا `Mutex` احساس می‌شود تا از دسترسی همزمان (Concurrent) به منابع مشترک جلوگیری شود.

#### 1.4.3 مرحله اتمام (Termination)

نخ زمانی به مرحله اتمام می‌رسد که کد تعیین شده به طور کامل اجرا شده باشد یا به دلیل خطا متوقف شده باشد.

**روش‌های اتمام نخ:**

1. **اتمام طبیعی:** کد متد به پایان می‌رسد و نخ به طور خودکار خاتمه می‌یابد
2. **اتمام با استثنا:** در صورت بروز خطا، نخ متوقف می‌شود
3. **اتمام اجباری:** استفاده از `Thread.Abort()` (منسوخ شده و توصیه نمی‌شود)

**تأثیرات مرحله اتمام:**

- تمام منابع اختصاص داده شده به نخ آزاد می‌شوند
- نخ دیگر قابل استفاده نیست و نمی‌توان دوباره `Start()` را روی آن فراخوانی کرد
- اگر نخ به دلیل خطا متوقف شده باشد، ممکن است منابع مشترک در وضعیت نامعتبر باقی بمانند

#### 1.4.4 مدیریت هماهنگی نخ‌ها با Join()

متد `Join()` یکی از ابزارهای مهم برای هماهنگی بین نخ‌ها است. این متد باعث می‌شود که نخ فعلی منتظر بماند تا نخ دیگری به طور کامل به پایان برسد.

**کاربرد Join():**

```csharp
Thread thread = new Thread(MyMethod);
thread.Start();

// نخ اصلی منتظر می‌ماند تا thread به پایان برسد
thread.Join();

// این کد فقط پس از اتمام thread اجرا می‌شود
Console.WriteLine("نخ به پایان رسید");
```

**تأثیرات و کاربردهای Join():**

1. **اطمینان از اتمام کار:** قبل از استفاده از نتایج یک نخ، می‌توانید از `Join()` استفاده کنید تا مطمئن شوید کار به پایان رسیده است

2. **هماهنگی ترتیبی (Sequential Coordination):** اگر نیاز دارید چندین نخ به ترتیب خاصی اجرا شوند، می‌توانید از `Join()` برای کنترل ترتیب استفاده کنید

3. **مدیریت منابع:** قبل از آزاد کردن منابع مشترک یا بستن برنامه، می‌توانید با `Join()` مطمئن شوید که تمام نخ‌ها به پایان رسیده‌اند

4. **استفاده از Join با زمان انتظار:** می‌توانید حداکثر زمان انتظار را مشخص کنید:

```csharp
if (thread.Join(TimeSpan.FromSeconds(5)))
{
    // نخ در زمان مشخص شده به پایان رسید
}
else
{
    // نخ در زمان مشخص شده به پایان نرسید
    // ممکن است نیاز به اقدام دیگری باشد
}
```

**نکته مهم:** استفاده از `Join()` باعث می‌شود نخ فعلی مسدود (Blocked) شود و منتظر بماند. اگر نخ هدف هرگز به پایان نرسد، نخ فعلی برای همیشه مسدود می‌ماند. بنابراین بهتر است از نسخه‌ای با زمان انتظار استفاده کنید.

#### 1.4.5 سناریوی پیچیده: هماهنگی چندین نخ با Join()

برای درک بهتر نحوه کار `Join()` در سناریوهای پیچیده، یک مثال عملی با سه نخ (نخ اصلی، نخ فرعی 1 و نخ فرعی 2) را بررسی می‌کنیم:

**سناریو:** نخ فرعی 1 منتظر اتمام نخ فرعی 2 است، و نخ اصلی ابتدا منتظر اتمام نخ فرعی 2 و سپس منتظر اتمام نخ فرعی 1 است.

```csharp
static void Main()
{
    Console.WriteLine("نخ اصلی شروع شد");
    
    // ایجاد نخ فرعی 2
    Thread thread2 = new Thread(() => {
        Console.WriteLine("نخ فرعی 2 شروع شد");
        Thread.Sleep(2000); // شبیه‌سازی کار
        Console.WriteLine("نخ فرعی 2 به پایان رسید");
    });
    
    // ایجاد نخ فرعی 1 که منتظر نخ فرعی 2 می‌ماند
    Thread thread1 = new Thread(() => {
        Console.WriteLine("نخ فرعی 1 شروع شد");
        
        // نخ فرعی 1 منتظر اتمام نخ فرعی 2 می‌ماند
        thread2.Join();
        Console.WriteLine("نخ فرعی 1: نخ فرعی 2 به پایان رسید، ادامه می‌دهم");
        
        Thread.Sleep(1000); // کار اضافی نخ فرعی 1
        Console.WriteLine("نخ فرعی 1 به پایان رسید");
    });
    
    // شروع هر دو نخ
    thread2.Start();
    thread1.Start();
    
    // نخ اصلی منتظر اتمام نخ فرعی 2 می‌ماند
    thread2.Join();
    Console.WriteLine("نخ اصلی: نخ فرعی 2 به پایان رسید");
    
    // سپس نخ اصلی منتظر اتمام نخ فرعی 1 می‌ماند
    thread1.Join();
    Console.WriteLine("نخ اصلی: نخ فرعی 1 به پایان رسید");
    Console.WriteLine("نخ اصلی به پایان رسید");
}
```

**خروجی احتمالی:**

```
نخ اصلی شروع شد
نخ فرعی 2 شروع شد
نخ فرعی 1 شروع شد
(2 ثانیه انتظار)
نخ فرعی 2 به پایان رسید
نخ فرعی 1: نخ فرعی 2 به پایان رسید، ادامه می‌دهم
نخ اصلی: نخ فرعی 2 به پایان رسید
(1 ثانیه انتظار)
نخ فرعی 1 به پایان رسید
نخ اصلی: نخ فرعی 1 به پایان رسید
نخ اصلی به پایان رسید
```

**نکات مهم این سناریو:**

1. **عبارت Join() می‌تواند از چندین نخ فراخوانی شود:** هم نخ اصلی و هم نخ فرعی 1 می‌توانند روی نخ فرعی 2 `Join()` فراخوانی کنند. این کاملاً مجاز است و هر دو نخ منتظر می‌مانند تا نخ فرعی 2 به پایان برسد.

2. **ترتیب Join() مهم است:** در این مثال، نخ اصلی ابتدا منتظر نخ فرعی 2 می‌ماند و سپس منتظر نخ فرعی 1. این ترتیب تضمین می‌کند که نخ اصلی می‌داند نخ فرعی 2 تمام شده است قبل از اینکه منتظر نخ فرعی 1 بماند.

3. **عبارت Join() در نخ‌های فرعی:** نخ فرعی 1 نیز می‌تواند از `Join()` استفاده کند تا منتظر نخ فرعی 2 بماند. این نشان می‌دهد که `Join()` فقط محدود به نخ اصلی نیست و هر نخی می‌تواند منتظر نخ دیگری بماند.

4. **زمان‌بندی و هماهنگی:** در این سناریو، نخ فرعی 1 نمی‌تواند کار خود را کامل کند تا زمانی که نخ فرعی 2 تمام شود. این یک وابستگی ترتیبی (Sequential Dependency) ایجاد می‌کند که می‌تواند برای هماهنگی کارهای مرتبط مفید باشد.

5. **مزیت استفاده از Join() در نخ‌های فرعی:** اگر نخ فرعی 1 نیاز به نتایج یا وضعیت نخ فرعی 2 دارد، استفاده از `Join()` در داخل نخ فرعی 1 تضمین می‌کند که کار نخ فرعی 2 قبل از ادامه کار نخ فرعی 1 تمام شده است.

**نکته احتیاطی:** در این سناریو، اگر نخ فرعی 2 هرگز به پایان نرسد، هم نخ اصلی و هم نخ فرعی 1 برای همیشه مسدود (Blocked) می‌مانند. برای جلوگیری از این مشکل، بهتر است از نسخه‌ای با زمان انتظار استفاده کنید:

```csharp
// در نخ فرعی 1
if (thread2.Join(TimeSpan.FromSeconds(5)))
{
    Console.WriteLine("نخ فرعی 1: نخ فرعی 2 به پایان رسید");
}
else
{
    Console.WriteLine("نخ فرعی 1: نخ فرعی 2 در زمان مشخص شده به پایان نرسید");
    // تصمیم‌گیری برای ادامه یا توقف
}
```

#### 1.4.6 نمودار چرخه حیات و انتقال بین مراحل

```
ایجاد (Creation)
    ↓
    Start()
    ↓
اجرا (Execution) ←→ [مسدود شده] ←→ [اجرا]
    ↓
    (کد به پایان می‌رسد یا خطا رخ می‌دهد)
    ↓
اتمام (Termination)
```

**نکات کلیدی:**

- انتقال از ایجاد به اجرا فقط با `Start()` امکان‌پذیر است
- یک نخ نمی‌تواند مستقیماً از ایجاد به اتمام برود
- نخ در مرحله اجرا می‌تواند چندین بار مسدود (Blocked) و آزاد شود
- پس از اتمام، نخ دیگر قابل استفاده نیست و باید نمونه جدیدی ایجاد شود

<a id="15-استفاده-از-threadsleep-و-threadjoin"></a>
### 1.5 استفاده از Thread.Sleep() و Thread.Join()

**متد `Thread.Sleep()`**: متد `Thread.Sleep()` به نخ فعلی دستور می‌دهد که به مدت زمان معین منتظر بماند.

```csharp
Thread.Sleep(1000); // Sleep for 1 second
```

**متد `Thread.Join()`**: این متد منتظر می‌ماند تا نخ دیگری اجرا شود و سپس ادامه دهد.

```csharp
thread.Join(); // Waits for thread to finish
```

## 2. مبانی Tasks (مفهوم و استفاده از تسک‌ها)

<a id="21-مقدمهای-بر-task-و-taskt-در-net"></a>
### 2.1 مقدمه‌ای بر Task و `Task<T>` در .NET

برای درک صحیح مفهوم `Task` در .NET، ابتدا باید تفاوت بین برنامه‌نویسی ناهمزمان (Asynchronous Programming) و همزمان (Concurrent Programming) را بشناسیم. این دو مفهوم اگرچه مرتبط هستند، اما اهداف و کاربردهای متفاوتی دارند.

#### تفاوت کلیدی: ناهمزمانی (Asynchronous) در مقابل همزمانی (Concurrent)

**برنامه‌نویسی ناهمزمان (Asynchronous Programming):**

ناهمزمانی (Asynchronous) به معنای انجام عملیات بدون مسدود کردن (Blocking) نخ فعلی است. در این الگو، وقتی یک عملیات زمان‌بر (مانند خواندن فایل، درخواست شبکه یا پردازش داده) شروع می‌شود، نخ اصلی منتظر نمی‌ماند و می‌تواند به کارهای دیگر بپردازد.

**ویژگی‌های کلیدی:**
- عملیات به صورت غیرمسدودکننده (Non-blocking) اجرا می‌شود
- نخ اصلی آزاد می‌ماند و می‌تواند کارهای دیگر انجام دهد
- مناسب برای عملیات I/O (خواندن/نوشتن فایل، درخواست‌های شبکه)
- استفاده بهینه از منابع سیستم

**مثال عملی:**

```csharp
public async Task<string> DownloadDataAsync()
{
    // این عملیات نخ اصلی را مسدود نمی‌کند
    var data = await DownloadFileAsync("file.txt");
    return data;
}

// استفاده در متد اصلی
public async Task Main()
{
    Console.WriteLine("شروع دانلود...");
    var result = await DownloadDataAsync();
    Console.WriteLine($"دانلود کامل شد: {result}");
    // در حین دانلود، برنامه می‌تواند کارهای دیگر انجام دهد
}
```

**برنامه‌نویسی همزمان (Concurrent Programming):**

همزمانی (Concurrency) به معنای اجرای چندین کار به صورت موازی (Parallel) است. در این الگو، چندین نخ یا تسک به طور همزمان (Concurrent) اجرا می‌شوند تا کارها سریع‌تر انجام شوند.

**ویژگی‌های کلیدی:**
- چندین عملیات به صورت موازی (Parallel) اجرا می‌شوند
- مناسب برای پردازش‌های CPU-intensive (پردازش‌های سنگین CPU)
- می‌تواند از چند هسته پردازنده استفاده کند
- نیاز به مدیریت منابع مشترک دارد

**مثال عملی:**

```csharp
// پردازش موازی چند فایل
var tasks = new List<Task>();
for (int i = 0; i < 10; i++)
{
    int fileNumber = i;
    tasks.Add(Task.Run(() => ProcessFile($"file{fileNumber}.txt")));
}

await Task.WhenAll(tasks); // منتظر اتمام همه تسک‌ها
```

**تحلیل حرفه‌ای: تاثیرات و تفاوت‌های `Task.Run` و `Task.WhenAll` در مثال بالا**

در این مثال، دو مفهوم کلیدی با هم ترکیب شده‌اند که هر کدام نقش متمایزی دارند:

**نقش و تاثیرات `Task.Run()`:**

عبارت `Task.Run()` یک تسک را در Thread Pool اجرا می‌کند و بلافاصله یک `Task` برمی‌گرداند. در این مثال:

1. **اجرای همزمان (Concurrent Execution):** هر فراخوانی `Task.Run()` یک تسک جدید در Thread Pool ایجاد می‌کند که به صورت موازی (Parallel) با سایر تسک‌ها اجرا می‌شود. این یعنی 10 فایل به طور همزمان (Concurrent) پردازش می‌شوند، نه به صورت ترتیبی (Sequential).

2. **مدیریت منابع:** Thread Pool به طور خودکار تعداد نخ‌های فعال را مدیریت می‌کند. اگر 10 تسک ایجاد شود، Thread Pool تصمیم می‌گیرد که چند نخ واقعی ایجاد کند (معمولاً برابر با تعداد هسته‌های CPU).

3. **عدم مسدود شدن (Non-blocking):** پس از فراخوانی `Task.Run()`، کد اصلی منتظر نمی‌ماند و به خط بعدی می‌رود. تمام 10 تسک تقریباً همزمان (Concurrent) شروع می‌شوند.

4. **زمان‌بندی:** هر تسک به محض اینکه یک نخ در Thread Pool آزاد شود، شروع به اجرا می‌کند. اگر Thread Pool فقط 4 نخ داشته باشد، ابتدا 4 تسک اجرا می‌شوند و بقیه در صف منتظر می‌مانند.

**نقش و تاثیرات `Task.WhenAll()`:**

عبارت `Task.WhenAll()` یک تسک جدید ایجاد می‌کند که منتظر می‌ماند تا تمام تسک‌های ورودی به پایان برسند:

1. **هماهنگی:** این متد تضمین می‌کند که کد بعد از `await Task.WhenAll()` فقط زمانی اجرا می‌شود که تمام 10 تسک به پایان رسیده باشند.

2. **مدیریت استثناها:** اگر هر یک از تسک‌ها خطا داشته باشد، `Task.WhenAll()` یک `AggregateException` پرتاب می‌کند که شامل تمام استثناهای تسک‌های ناموفق است.

3. **بهینه‌سازی:** `Task.WhenAll()` خودش یک تسک جدید ایجاد نمی‌کند، بلکه یک continuation ایجاد می‌کند که منتظر اتمام همه تسک‌ها می‌ماند. این کارآمدتر از استفاده از حلقه و `await` برای هر تسک است.

4. **عدم مسدود شدن (Non-blocking):** برخلاف `Task.WaitAll()` که مسدودکننده (Blocking) است، `await Task.WhenAll()` غیرمسدودکننده (Non-blocking) است و نخ فعلی را آزاد می‌کند.

**تفاوت کلیدی در نحوه کار:**

- **`Task.Run()`:** ایجاد و شروع اجرای یک تسک - هر فراخوانی یک تسک مستقل ایجاد می‌کند
- **`Task.WhenAll()`:** هماهنگی و انتظار برای اتمام چندین تسک - خودش تسک جدیدی ایجاد نمی‌کند، فقط منتظر می‌ماند

#### مفاهیم کلیدی: Thread Pool و Continuation

برای درک کامل نحوه کار `Task.Run()` و `Task.WhenAll()`، باید دو مفهوم مهم را بشناسیم:

**1. Thread Pool چیست؟**

باید گفت که Thread Pool یک مجموعه از نخ‌های از پیش ایجاد شده است که .NET برای اجرای تسک‌ها از آن استفاده می‌کند. به جای ایجاد یک نخ جدید برای هر تسک (که هزینه‌بر است)، Thread Pool نخ‌های موجود را دوباره استفاده می‌کند.

**ویژگی‌های Thread Pool:**

- **مدیریت خودکار:** Thread Pool به طور خودکار تعداد نخ‌های فعال را بر اساس بار کاری تنظیم می‌کند
- **بازاستفاده از نخ‌ها:** نخ‌ها پس از اتمام یک تسک، برای تسک بعدی استفاده می‌شوند
- **محدودیت تعداد:** Thread Pool تعداد نخ‌ها را محدود می‌کند تا از مصرف بیش از حد منابع جلوگیری کند
- **صف انتظار:** اگر همه نخ‌ها مشغول باشند، تسک‌های جدید در صف منتظر می‌مانند

**مثال عملی:**

```csharp
// بدون Thread Pool (نادرست - هزینه‌بر)
for (int i = 0; i < 100; i++)
{
    var thread = new Thread(() => DoWork(i));
    thread.Start(); // ایجاد 100 نخ جدید - بسیار هزینه‌بر!
}

// با Thread Pool (درست - بهینه)
for (int i = 0; i < 100; i++)
{
    Task.Run(() => DoWork(i)); // استفاده از نخ‌های موجود در Thread Pool
}
```

**چگونگی کار Thread Pool در مثال ما:**

```csharp
var tasks = new List<Task>();
for (int i = 0; i < 10; i++)
{
    int fileNumber = i;
    tasks.Add(Task.Run(() => ProcessFile($"file{fileNumber}.txt")));
}
```

در این مثال:
1. عبارت `Task.Run()` تسک را به Thread Pool ارسال می‌کند
2. سپس Thread Pool بررسی می‌کند که آیا نخ آزاد وجود دارد یا نه
3. اگر نخ آزاد باشد، تسک بلافاصله شروع می‌شود
4. اگر همه نخ‌ها مشغول باشند، تسک در صف منتظر می‌ماند
5. وقتی یک نخ آزاد می‌شود، تسک بعدی از صف شروع می‌شود

**مزایای استفاده از Thread Pool:**

- **کارایی:** ایجاد نخ جدید هزینه‌بر است (حدود 1MB حافظه). Thread Pool این هزینه را کاهش می‌دهد
- **مدیریت منابع:** Thread Pool از ایجاد تعداد زیاد نخ جلوگیری می‌کند
- **بهینه‌سازی:** Thread Pool تعداد نخ‌ها را بر اساس تعداد هسته‌های CPU تنظیم می‌کند

**2. مفهوم Continuation چیست؟**

عبارت Continuation یک کد یا عملیاتی است که پس از اتمام یک تسک اجرا می‌شود. وقتی از `await` استفاده می‌کنید، در واقع یک continuation ایجاد می‌کنید.

**مثال ساده:**

```csharp
var task = Task.Run(() => DoWork());
await task; // این یک continuation ایجاد می‌کند
Console.WriteLine("کار تمام شد"); // این کد continuation است
```

**چگونگی کار Continuation در `Task.WhenAll()`:**

وقتی می‌نویسید:

```csharp
await Task.WhenAll(tasks);
```

در پشت صحنه چه اتفاقی می‌افتد:

1. عبارت `Task.WhenAll()` یک continuation ایجاد می‌کند (نه یک تسک جدید)
2. این continuation به تمام تسک‌های ورودی "گوش می‌دهد"
3. وقتی همه تسک‌ها به پایان برسند، continuation فعال می‌شود
4. کد بعد از `await` اجرا می‌شود

**تفاوت بین ایجاد تسک جدید و ایجاد Continuation:**

```csharp
// روش 1: ایجاد تسک جدید (هزینه‌بر)
Task task1 = Task.Run(() => {
    // منتظر اتمام همه تسک‌ها
    Task.WaitAll(tasks.ToArray());
    // سپس کار دیگری انجام می‌دهد
});

// روش 2: ایجاد Continuation (بهینه)
await Task.WhenAll(tasks); // فقط یک continuation ایجاد می‌شود
// کد بعدی به عنوان continuation اجرا می‌شود
```

**مزایای استفاده از Continuation:**

- **کارایی:** Continuation سبک‌تر از ایجاد تسک جدید است
- **عدم مسدود شدن (Non-blocking):** وقتی از `await` و Continuation استفاده می‌کنید، نخ فعلی مسدود نمی‌شود. به جای اینکه نخ منتظر بماند تا تسک تمام شود، یک Continuation ثبت می‌شود و نخ آزاد می‌ماند تا کارهای دیگر را انجام دهد. وقتی تسک به پایان برسد، Continuation اجرا می‌شود. این یعنی نخ می‌تواند در حین انتظار برای اتمام تسک، به کارهای دیگر بپردازد و منابع سیستم بهینه‌تر استفاده می‌شوند.
- **مدیریت بهتر:** .NET می‌تواند continuation‌ها را بهینه‌تر مدیریت کند

**توضیح تفصیلی عدم مسدود شدن:**

برای درک بهتر، دو روش را مقایسه می‌کنیم:

**روش مسدودکننده (Blocking) - بدون Continuation:**

```csharp
// نخ فعلی مسدود می‌شود و منتظر می‌ماند
var task = Task.Run(() => DoLongWork());
task.Wait(); // نخ فعلی اینجا متوقف می‌شود و منتظر می‌ماند
Console.WriteLine("کار تمام شد"); // این کد فقط بعد از اتمام تسک اجرا می‌شود
// در این مدت، نخ نمی‌تواند کار دیگری انجام دهد
```

در این روش، نخ فعلی در خط `task.Wait()` متوقف می‌شود و تا زمانی که تسک تمام نشود، هیچ کاری نمی‌تواند انجام دهد. این یعنی منابع CPU هدر می‌رود.

**روش غیرمسدودکننده (Non-blocking) - با Continuation:**

```csharp
// نخ فعلی مسدود نمی‌شود
var task = Task.Run(() => DoLongWork());
await task; // یک Continuation ثبت می‌شود و نخ آزاد می‌ماند
Console.WriteLine("کار تمام شد"); // این کد به عنوان Continuation اجرا می‌شود
```

در این روش:
1. وقتی به `await task` می‌رسیم، یک Continuation ثبت می‌شود که می‌گوید: "وقتی این تسک تمام شد، کد بعدی را اجرا کن"
2. نخ فعلی آزاد می‌شود و می‌تواند به کارهای دیگر بپردازد (مثلاً پردازش رویدادهای UI، اجرای تسک‌های دیگر، و غیره)
3. وقتی تسک `DoLongWork()` تمام می‌شود، Continuation فعال می‌شود و کد بعد از `await` (یعنی `Console.WriteLine`) اجرا می‌شود
4. در این مدت، نخ آزاد بوده و می‌توانسته کارهای دیگر انجام دهد

**مثال عملی برای درک بهتر:**

```csharp
public async Task ProcessMultipleFiles()
{
    var task1 = Task.Run(() => ProcessFile("file1.txt")); // شروع پردازش فایل 1
    
    // در اینجا نخ آزاد است و می‌تواند کارهای دیگر انجام دهد
    // مثلاً می‌تواند UI را به‌روزرسانی کند یا تسک‌های دیگر را شروع کند
    
    await task1; // Continuation ثبت می‌شود، نخ آزاد می‌ماند
    // وقتی task1 تمام شد، این خط اجرا می‌شود:
    Console.WriteLine("فایل 1 پردازش شد");
    
    var task2 = Task.Run(() => ProcessFile("file2.txt"));
    await task2; // دوباره Continuation، نخ آزاد می‌ماند
    Console.WriteLine("فایل 2 پردازش شد");
}
```

**خلاصه:** Continuation به شما اجازه می‌دهد که "بگو چه کاری انجام بده وقتی تسک تمام شد" بدون اینکه نخ فعلی را مسدود کنید. این باعث می‌شود برنامه‌های شما واکنش‌گراتر و کارآمدتر شوند، به خصوص در برنامه‌های UI که باید همیشه پاسخگو باشند.

**مثال پیشرفته: Continuation زنجیره‌ای**

```csharp
var task1 = Task.Run(() => ProcessFile("file1.txt"));
var task2 = Task.Run(() => ProcessFile("file2.txt"));

// Continuation برای task1
await task1;
Console.WriteLine("فایل 1 پردازش شد");

// Continuation برای task2
await task2;
Console.WriteLine("فایل 2 پردازش شد");

// Continuation برای هر دو
await Task.WhenAll(task1, task2);
Console.WriteLine("هر دو فایل پردازش شدند");
```

**خلاصه:**

- مفهوم **Thread Pool:** مجموعه نخ‌های از پیش ایجاد شده که برای اجرای تسک‌ها استفاده می‌شود - کارآمدتر از ایجاد نخ جدید
- مفهوم **Continuation:** کدی که پس از اتمام یک تسک اجرا می‌شود - سبک‌تر از ایجاد تسک جدید
- عبارت **`Task.Run()`:** از Thread Pool استفاده می‌کند
- عبارت **`Task.WhenAll()`:** یک Continuation ایجاد می‌کند که منتظر اتمام همه تسک‌ها می‌ماند

**مثال مقایسه‌ای برای درک بهتر:**

```csharp
// روش نادرست: مسدودکننده (Blocking) و کند
for (int i = 0; i < 10; i++)
{
    await Task.Run(() => ProcessFile($"file{i}.txt")); // هر تسک منتظر تسک قبلی می‌ماند
}
// زمان کل: مجموع زمان همه تسک‌ها (ترتیبی - Sequential)

// روش درست: غیرمسدودکننده (Non-blocking) و سریع
var tasks = new List<Task>();
for (int i = 0; i < 10; i++)
{
    tasks.Add(Task.Run(() => ProcessFile($"file{i}.txt"))); // همه همزمان (Concurrent) شروع می‌شوند
}
await Task.WhenAll(tasks); // منتظر اتمام همه
// زمان کل: زمان طولانی‌ترین تسک (موازی - Parallel)
```

**نکات پیشرفته:**

1. **مدیریت استثناها:** برای مدیریت خطاهای هر تسک به صورت جداگانه:

```csharp
var tasks = new List<Task>();
for (int i = 0; i < 10; i++)
{
    int fileNumber = i;
    tasks.Add(Task.Run(async () => {
        try
        {
            await ProcessFileAsync($"file{fileNumber}.txt");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"خطا در پردازش فایل {fileNumber}: {ex.Message}");
        }
    }));
}

try
{
    await Task.WhenAll(tasks);
}
catch (AggregateException ae)
{
    // مدیریت استثناهای جمع‌آوری شده
    foreach (var ex in ae.InnerExceptions)
    {
        Console.WriteLine($"خطا: {ex.Message}");
    }
}
```

2. **استفاده از `Task<T>` برای دریافت نتایج:**

```csharp
var tasks = new List<Task<string>>();
for (int i = 0; i < 10; i++)
{
    int fileNumber = i;
    tasks.Add(Task.Run(() => ProcessFileAndReturnResult($"file{fileNumber}.txt")));
}

string[] results = await Task.WhenAll(tasks);
// results شامل نتایج همه تسک‌ها به ترتیب است
```

3. **کنترل تعداد تسک‌های همزمان (Concurrent Tasks):** برای جلوگیری از ایجاد تعداد زیاد تسک:

```csharp
var semaphore = new SemaphoreSlim(4); // حداکثر 4 تسک همزمان (Concurrent)
var tasks = new List<Task>();

for (int i = 0; i < 10; i++)
{
    int fileNumber = i;
    tasks.Add(Task.Run(async () => {
        await semaphore.WaitAsync();
        try
        {
            await ProcessFileAsync($"file{fileNumber}.txt");
        }
        finally
        {
            semaphore.Release();
        }
    }));
}

await Task.WhenAll(tasks);
```

**خلاصه تاثیرات:**

- **عبارت `Task.Run()`:** ایجاد تسک‌های موازی (Parallel) → بهبود عملکرد از طریق پردازش همزمان (Concurrent)
- **عبارت `Task.WhenAll()`:** هماهنگی تسک‌ها → اطمینان از اتمام کامل قبل از ادامه
- **ترکیب آن‌ها:** الگوی قدرتمند برای پردازش موازی (Parallel) با هماهنگی کامل

#### مفهوم Task در .NET

هر دوی `Task` و `Task<T>` کلاس‌های اصلی در .NET برای مدیریت عملیات ناهمزمان (Asynchronous) و همزمان (Concurrent) هستند. این کلاس‌ها نمایانگر یک واحد کار هستند که می‌توانند به صورت ناهمزمان (Asynchronous) اجرا شوند.

**تفاوت `Task` و `Task<T>`:**
- عبارت `Task`: برای عملیات‌هایی که نتیجه برنمی‌گردانند
- عبارت `Task<T>`: برای عملیات‌هایی که نتیجه از نوع `T` برمی‌گردانند

**مثال‌های کاربردی:**

```csharp
// Task بدون نتیجه
Task task = Task.Run(() => {
    Console.WriteLine("کار در پس‌زمینه انجام می‌شود");
    Thread.Sleep(2000);
});

// Task با نتیجه
Task<int> taskWithResult = Task.Run(() => {
    // محاسبه پیچیده
    return CalculateSum(1, 100);
});

int result = await taskWithResult;
Console.WriteLine($"نتیجه: {result}");
```

#### کاربردهای عملی Task

**1. جلوگیری از مسدود شدن (Blocking) UI:**

در برنامه‌های Windows Forms یا WPF، استفاده از `Task` باعث می‌شود رابط کاربری مسدود (Blocked) نشود:

```csharp
private async void Button_Click(object sender, EventArgs e)
{
    // بدون Task، UI مسدود (Blocked) می‌شود
    // با Task، UI آزاد می‌ماند
    await LoadDataAsync();
    UpdateUI();
}
```

**2. انجام عملیات I/O بهینه:**

```csharp
public async Task<string> ReadFileAsync(string path)
{
    using var reader = new StreamReader(path);
    return await reader.ReadToEndAsync(); // غیرمسدودکننده (Non-blocking)
}
```

**3. پردازش موازی (Parallel) داده‌ها:**

```csharp
var data = Enumerable.Range(1, 1000).ToList();
var results = await Task.WhenAll(
    data.Select(item => Task.Run(() => ProcessItem(item)))
);
```

#### تاثیرات و مزایای استفاده از Task

**مزایا:**
- **بهبود عملکرد:** استفاده بهینه از منابع سیستم
- **تجربه کاربری بهتر:** جلوگیری از مسدود شدن (Blocking) UI
- **مقیاس‌پذیری:** امکان مدیریت تعداد زیادی عملیات همزمان (Concurrent)
- **مدیریت خطا:** استفاده از `try-catch` برای مدیریت استثناها در تسک‌ها

**نکات مهم:**
- استفاده از `await` به جای `Wait()` یا `Result` برای جلوگیری از deadlock (قفل مرگ)
- مدیریت صحیح استثناها با `try-catch` در متدهای `async`
- استفاده از `ConfigureAwait(false)` در کتابخانه‌ها برای جلوگیری از deadlock (قفل مرگ)

**مثال مدیریت خطا:**

```csharp
try
{
    var result = await SomeAsyncOperation();
}
catch (Exception ex)
{
    Console.WriteLine($"خطا: {ex.Message}");
}
```

#### خلاصه و نکات کلیدی

- **ناهمزمانی (Asynchronous):** انجام عملیات بدون مسدود کردن (Blocking) نخ فعلی - مناسب برای I/O
- **همزمانی (Concurrency):** اجرای چندین کار به صورت موازی (Parallel) - مناسب برای پردازش‌های CPU-intensive
- **مفهوم Task:** ابزار اصلی .NET برای مدیریت عملیات ناهمزمان (Asynchronous) و همزمان (Concurrent)
- **مفهوم async/await:** الگوی توصیه شده برای نوشتن کدهای ناهمزمان در C#

استفاده صحیح از `Task` و `async/await` باعث می‌شود برنامه‌های شما کارآمدتر، واکنش‌گراتر و مقیاس‌پذیرتر شوند.

<a id="22-استفاده-از-taskrun-و-taskfactorystartnew"></a>
### 2.2 استفاده از Task.Run() و Task.Factory.StartNew()

**استفاده از `Task.Run()`**: متد `Run()` برای اجرای یک تسک ناهمزمان (Asynchronous) استفاده می‌شود.

```csharp
Task task = Task.Run(() => SomeMethod());
```

**استفاده از `Task.Factory.StartNew()`**: روش قدیمی‌تری برای شروع تسک است که به صورت پیش‌فرض در یک نخ جدید اجرا می‌شود.

```csharp
Task task = Task.Factory.StartNew(() => SomeMethod());
```

<a id="23-مفهوم-task-scheduler-مدیر-تسک"></a>
### 2.3 مفهوم Task Scheduler (مدیر تسک)

مفهوم Task Scheduler (مدیر تسک) یک جزء کلیدی در .NET است که مسئولیت تصمیم‌گیری درباره نحوه و زمان اجرای تسک‌ها را بر عهده دارد. وقتی شما یک تسک ایجاد می‌کنید (مثلاً با `Task.Run()`)، Task Scheduler تصمیم می‌گیرد که این تسک کجا و چه زمانی اجرا شود.

#### مفهوم Task Scheduler چیست و چه کاری انجام می‌دهد؟

باید گفت که Task Scheduler یک سیستم مدیریتی است که:

1. **تعیین محل اجرا:** تصمیم می‌گیرد که تسک در کدام نخ اجرا شود (Thread Pool، نخ UI، یا نخ خاص)
2. **زمان‌بندی:** تصمیم می‌گیرد که تسک چه زمانی اجرا شود (بلافاصله یا بعداً)
3. **اولویت‌بندی:** در صورت وجود چندین تسک، تصمیم می‌گیرد که کدام یک اول اجرا شود
4. **مدیریت منابع:** تعداد تسک‌های همزمان را کنترل می‌کند تا از بارگذاری بیش از حد سیستم جلوگیری کند

#### چطور کار می‌کند؟

وقتی شما یک تسک ایجاد می‌کنید:

```csharp
var task = Task.Run(() => DoWork());
```

در پشت صحنه چه اتفاقی می‌افتد:

1. تسک به Task Scheduler ارسال می‌شود
2.  سپس Task Scheduler بررسی می‌کند که آیا نخ آزاد در Thread Pool وجود دارد یا نه
3. اگر نخ آزاد باشد، تسک بلافاصله به آن نخ اختصاص داده می‌شود
4. اگر همه نخ‌ها مشغول باشند، تسک در صف انتظار قرار می‌گیرد
5. وقتی یک نخ آزاد می‌شود، Task Scheduler تسک بعدی را از صف برمی‌دارد و به آن نخ اختصاص می‌دهد

#### مثال عملی:

```csharp
// ایجاد 20 تسک
var tasks = new List<Task>();
for (int i = 0; i < 20; i++)
{
    int taskNumber = i;
    tasks.Add(Task.Run(() => {
        Console.WriteLine($"تسک {taskNumber} در حال اجرا");
        Thread.Sleep(1000);
    }));
}

await Task.WhenAll(tasks);
```

در این مثال:
- 20 تسک ایجاد می‌شوند
- سپس Task Scheduler تصمیم می‌گیرد که چند نخ برای اجرای آن‌ها استفاده شود (معمولاً برابر با تعداد هسته‌های CPU)
- اگر سیستم 4 هسته داشته باشد، ابتدا 4 تسک همزمان اجرا می‌شوند
- بقیه تسک‌ها در صف منتظر می‌مانند
- وقتی یک تسک تمام می‌شود، Task Scheduler تسک بعدی را از صف برمی‌دارد و اجرا می‌کند

#### انواع Task Scheduler:

**1. نوع ThreadPoolTaskScheduler (پیش‌فرض):**
- برای تسک‌های عادی استفاده می‌شود
- از Thread Pool استفاده می‌کند
- مناسب برای اکثر سناریوها

**2. نوع SynchronizationContextTaskScheduler:**
- برای برنامه‌های UI استفاده می‌شود
- تضمین می‌کند که Continuation‌ها در نخ UI اجرا شوند
- در Windows Forms و WPF به صورت خودکار استفاده می‌شود

**مثال:**

```csharp
// در یک برنامه Windows Forms
private async void Button_Click(object sender, EventArgs e)
{
    // این تسک در Thread Pool اجرا می‌شود
    await Task.Run(() => DoHeavyWork());
    
    // این کد (Continuation) در نخ UI اجرا می‌شود
    // به خاطر SynchronizationContextTaskScheduler
    label.Text = "کار تمام شد";
}
```

#### چرا Task Scheduler مهم است؟

1. **بهینه‌سازی عملکرد:** Task Scheduler از ایجاد تعداد زیاد نخ جلوگیری می‌کند و منابع سیستم را بهینه استفاده می‌کند

2. **مدیریت خودکار:** شما نیازی ندارید که خودتان نخ‌ها را مدیریت کنید. Task Scheduler این کار را به صورت خودکار انجام می‌دهد

3. **انعطاف‌پذیری:** می‌توانید Task Scheduler سفارشی ایجاد کنید برای سناریوهای خاص

4. **هماهنگی با UI:** در برنامه‌های UI، سیستم Task Scheduler تضمین می‌کند که به‌روزرسانی‌های UI در نخ صحیح انجام شوند

#### خلاصه:

مفهوم Task Scheduler (مدیر تسک) یک سیستم مدیریتی است که:
- تصمیم می‌گیرد تسک‌ها کجا و چه زمانی اجرا شوند
- از Thread Pool برای اجرای تسک‌ها استفاده می‌کند
- تعداد تسک‌های همزمان را کنترل می‌کند
- در برنامه‌های UI، Continuation‌ها را در نخ صحیح اجرا می‌کند

شما معمولاً مستقیماً با Task Scheduler کار نمی‌کنید، اما درک نحوه کار آن به شما کمک می‌کند تا برنامه‌های بهینه‌تری بنویسید.

<a id="24-برنامهنویسی-ناهمزمان-با-async-و-await"></a>
### 2.4 برنامه‌نویسی ناهمزمان با async و await

در `C#`، برای نوشتن برنامه‌های ناهمزمان (Asynchronous) از کلمات کلیدی `async` و `await` استفاده می‌کنیم:

```csharp
public async Task MyMethodAsync() {
    await Task.Delay(1000); // Non-blocking delay
}
```

کلمه کلیدی `await` اجازه می‌دهد که متد تا اتمام تسک منتظر بماند بدون اینکه نخ اصلی را مسدود (Block) کند.

<a id="25-درک-taskwhenall-و-taskwhenany"></a>
### 2.5 درک Task.WhenAll() و Task.WhenAny()

**عبارت `Task.WhenAll()`**: زمانی که می‌خواهیم چند تسک را به طور همزمان (Concurrent) اجرا کنیم و منتظر اتمام همه آن‌ها باشیم.

```csharp
await Task.WhenAll(task1, task2);
```

**عبارت `Task.WhenAny()`**: زمانی که می‌خواهیم تا پایان اولین تسکی که به اتمام می‌رسد منتظر بمانیم.

```csharp
await Task.WhenAny(task1, task2);
```

## 3. مقایسه Threading و Tasks

<a id="31-تفاوت-بین-نخها-و-تسکها"></a>
### 3.1 تفاوت بین نخ‌ها و تسک‌ها

- **نخ‌ها**: یک واحد پردازشی هستند که به طور همزمان (Concurrent) در یک برنامه اجرا می‌شوند و می‌توانند به صورت مستقیم با سیستم عامل ارتباط برقرار کنند.

- **تسک‌ها**: نمایانگر واحدهای کار در سطح بالاتر هستند که بر اساس نخ‌ها اجرا می‌شوند، ولی کار کردن با تسک‌ها برای مدیریت بهتر منابع و پیاده‌سازی برنامه‌های ناهمزمان (Asynchronous) و بهینه‌تر مناسب‌تر است.

<a id="32-کی-از-نخها-استفاده-کنیم-و-کی-از-تسکها"></a>
### 3.2 کی از نخ‌ها استفاده کنیم و کی از تسک‌ها؟

- از نخ‌ها زمانی استفاده کنید که نیاز به پردازش موازی (Parallel) با کنترل دقیق و زمان‌بندی دارید.

- از تسک‌ها برای اجرای برنامه‌های ناهمزمان (Asynchronous) و بهینه استفاده کنید، مخصوصاً زمانی که می‌خواهید به صورت همزمان (Concurrent) تعداد زیادی عملیات انجام دهید بدون اینکه منابع سیستم را به طور غیرضروری مصرف کنید.

<a id="33-تفاوت-parallel-موازی-و-concurrent-همزمان"></a>
### 3.3 تفاوت Parallel (موازی) و Concurrent (همزمان)

این دو مفهوم اگرچه مرتبط هستند، اما تفاوت‌های مهمی دارند:

#### Parallel (موازی):

**تعریف:** اجرای واقعی چندین کار به صورت همزمان روی چند هسته CPU.

**ویژگی‌ها:**
- نیاز به چند هسته CPU دارد
- کارها واقعاً در یک لحظه اجرا می‌شوند
- مناسب برای پردازش‌های CPU-intensive (پردازش‌های سنگین CPU)
- سرعت اجرا به تعداد هسته‌های CPU بستگی دارد

**مثال:**

```csharp
// پردازش موازی (Parallel) - نیاز به چند هسته CPU
Parallel.For(0, 1000, i => {
    // این کدها واقعاً همزمان روی هسته‌های مختلف اجرا می‌شوند
    ProcessData(i);
});
```

#### Concurrent (همزمان):

**تعریف:** مدیریت چندین کار که ممکن است در زمان‌های مختلف اجرا شوند، اما به نظر می‌رسد همزمان هستند.

**ویژگی‌ها:**
- می‌تواند روی یک هسته CPU هم کار کند
- کارها به صورت سریع جابجا می‌شوند (time-slicing)
- مناسب برای عملیات I/O و کارهای ناهمزمان
- سیستم عامل بین کارها جابجا می‌شود

**مثال:**

```csharp
// پردازش همزمان (Concurrent) - می‌تواند روی یک هسته هم کار کند
var tasks = new List<Task>();
for (int i = 0; i < 1000; i++)
{
    tasks.Add(Task.Run(() => DownloadFile(i)));
}
await Task.WhenAll(tasks);
```

#### تفاوت کلیدی:

| ویژگی | Parallel (موازی) | Concurrent (همزمان) |
|-------|------------------|---------------------|
| **نیاز به چند هسته** | بله | خیر |
| **اجرای واقعی همزمان** | بله | خیر (جابجایی سریع) |
| **مناسب برای** | CPU-intensive | I/O و ناهمزمان |
| **مثال** | پردازش تصویر، محاسبات سنگین | دانلود فایل، درخواست شبکه |

#### مثال عملی برای درک بهتر:

```csharp
// Concurrent (همزمان) - می‌تواند روی یک هسته هم کار کند
// سیستم عامل بین تسک‌ها جابجا می‌شود
var tasks = new List<Task>();
for (int i = 0; i < 10; i++)
{
    tasks.Add(Task.Run(() => {
        Thread.Sleep(1000); // شبیه‌سازی کار
    }));
}
await Task.WhenAll(tasks);
// زمان: حدود 1 ثانیه (اگر یک هسته باشد) یا کمتر (اگر چند هسته باشد)

// Parallel (موازی) - نیاز به چند هسته
// کارها واقعاً همزمان روی هسته‌های مختلف اجرا می‌شوند
Parallel.For(0, 10, i => {
    Thread.Sleep(1000); // شبیه‌سازی کار
});
// زمان: حدود 1 ثانیه (اگر 10 هسته داشته باشیم) یا بیشتر (اگر هسته کمتری داشته باشیم)
```

#### خلاصه:

- **روش Parallel (موازی):** اجرای واقعی همزمان روی چند هسته - برای CPU-intensive
- **روش Concurrent (همزمان):** مدیریت چندین کار که به نظر همزمان هستند - برای I/O و ناهمزمان
- **نکته:** یک برنامه می‌تواند هم Parallel و هم Concurrent باشد. مثلاً چندین تسک Concurrent که هر کدام پردازش Parallel انجام می‌دهند.

## نکات پیشرفته و به‌روز شده در C# 13 و .NET 10

<a id="1-استفاده-از-valuetask-به-جای-task-برای-بهینهسازی-عملکرد"></a>
### 1. استفاده از ValueTask به جای Task برای بهینه‌سازی عملکرد

یکی از بهبودهای مهم در C# 13 و .NET 10 معرفی `ValueTask` است که برای بهینه‌سازی عملکرد در مواقعی که نیاز به بازگشت سریع نتیجه داریم، توصیه می‌شود. در سناریوهایی که نتیجه معمولاً از کش حافظه باز می‌گردد یا به سرعت محاسبه می‌شود، استفاده از `Task` می‌تواند بار اضافی در تخصیص حافظه ایجاد کند.

#### چرا ValueTask مفید است؟

عبارت `ValueTask` می‌تواند به جای `Task` استفاده شود تا از تخصیص حافظه اضافی جلوگیری کند. وقتی نتیجه بلافاصله موجود است، `ValueTask` از حافظه اضافی برای نگهداری نتیجه جلوگیری می‌کند.

در حالی که `Task` یک شیء هویتی است که همیشه یک شی از نوع `Task` را به خود اختصاص می‌دهد، `ValueTask` می‌تواند در مواقعی که نیازی به تخصیص شی نیست، از همین نتیجه استفاده کند.

**کد مثال:**

```csharp
public async ValueTask<int> GetValueAsync(bool fast)
{
    if (fast)
    {
        return 42;  // سریع و بدون تخصیص اضافی
    }
    else
    {
        await Task.Delay(1000);  // عملیات سنگین و زمان‌بر
        return 42;
    }
}
```

#### تاثیرات استفاده از ValueTask:

- اگر عملیات سریع باشد، `ValueTask` بدون ایجاد شی جدید از حافظه استفاده می‌کند، در حالی که `Task` همیشه یک شی جدید ایجاد می‌کند.

- برای عملیات سنگین که نیاز به تاخیر دارند، `ValueTask` مانند `Task` عمل می‌کند و به صورت معمولی تخصیص حافظه خواهد داشت.

<a id="2-بهبودهای-مدیریت-نخها-و-task-scheduler-در-net-10"></a>
### 2. بهبودهای مدیریت نخ‌ها و Task Scheduler در .NET 10

در .NET 10، بهبودهایی در نحوه مدیریت نخ‌ها و مدیر تسک (Task Scheduler) ایجاد شده است که باعث بهینه‌سازی پردازش‌های موازی (Parallel) و ناهمزمان (Asynchronous) می‌شود. این بهبودها به شما اجازه می‌دهد برنامه‌هایی با کارایی بیشتر و بهتر بسازید.

#### سیستم Task Scheduler جدید در .NET 10:

در نسخه‌های قبلی، سیستم زمان‌بندی تسک‌ها به شکل ساده‌ای کار می‌کرد و انتخاب نخ‌ها برای اجرا اغلب به صورت تصادفی بود.

در .NET 10، مدیریت تسک‌ها بهبود یافته و کارایی بهتر در محیط‌های همزمانی (Concurrency) و موازی (Parallel) ایجاد شده است. اکنون می‌توانید اولویت‌بندی نخ‌ها را کنترل کرده و برنامه‌های ناهمزمان (Asynchronous) بهینه‌تری داشته باشید.

**کد مثال:**

در .NET 10، می‌توانید از `TaskScheduler` برای اولویت‌بندی تسک‌ها استفاده کنید:

```csharp
public static async Task Main(string[] args)
{
    var scheduler = new TaskScheduler(100); // ایجاد یک scheduler سفارشی با 100 نخ

    var tasks = new List<Task>();
    for (int i = 0; i < 5; i++)
    {
        int taskId = i;
        tasks.Add(Task.Factory.StartNew(() =>
        {
            // تسک‌های با اولویت بالا اجرا می‌شوند
            Console.WriteLine($"Task {taskId} is running on thread {Thread.CurrentThread.ManagedThreadId}");
        }, CancellationToken.None, TaskCreationOptions.None, scheduler));
    }
    await Task.WhenAll(tasks);
}
```

#### تاثیرات:

- **موازی بودن (Parallel):** تسک‌ها به صورت بهتر و با اولویت‌بندی بیشتر اجرا می‌شوند.

- **سفارشی‌سازی Task Scheduler:** شما می‌توانید نحوه تخصیص نخ‌ها به تسک‌ها را در محیط‌های موازی (Parallel) مدیریت کنید تا کارایی بیشتری به دست آورید.

<a id="3-بهبود-در-برنامهنویسی-موازی-parallel-programming-و-دادههای-موازی-dataflow"></a>
### 3. بهبود در برنامه‌نویسی موازی (Parallel Programming) و داده‌های موازی (Dataflow)

در .NET 10، بهبودهایی در برنامه‌نویسی موازی (Parallel Programming) و مدیریت جریان داده‌ها (Dataflow) ایجاد شده است که به شما این امکان را می‌دهد که پردازش‌های موازی (Parallel) را به راحتی انجام دهید و داده‌ها را به طور موازی (Parallel) و بهینه‌تری مدیریت کنید.

#### برنامه‌نویسی موازی (Parallel Programming) با استفاده از Parallel.ForEach و Parallel.For:

در این نسخه از .NET، بهبودهایی در کارایی پردازش‌های موازی (Parallel) ایجاد شده که باعث می‌شود حلقه‌های موازی (Parallel) بهتر و سریع‌تر اجرا شوند. همچنین کنترل بیشتری روی نحوه تقسیم کارها بین نخ‌ها فراهم می‌شود.

**کد مثال:**

```csharp
var numbers = Enumerable.Range(1, 1000).ToArray();

Parallel.ForEach(numbers, (number) =>
{
    // پردازش موازی (Parallel) برای هر عدد
    Console.WriteLine($"Processing {number} on thread {Thread.CurrentThread.ManagedThreadId}");
});
```

#### تاثیرات استفاده از Parallel.ForEach:

- عبارت `Parallel.ForEach` با توزیع خودکار کارها بین نخ‌های موجود، سرعت پردازش را در مقایسه با پردازش سریعی که نیاز به مدیریت دستی نخ‌ها دارد، بهینه‌تر می‌کند.

- در این نسخه از .NET، `Parallel.ForEach` به طور خودکار بهینه شده و می‌تواند بسته به نیاز سیستم، تعداد نخ‌ها را تنظیم کند.

#### Dataflow (جریان داده) در .NET 10

ابزار `Dataflow` یکی از قدرتمندترین ابزارها برای انجام پردازش‌های موازی (Parallel) است. در .NET 10، امکانات جدیدی برای استفاده از جریان داده (Dataflow) فراهم شده است که به شما کمک می‌کند داده‌ها را به طور موازی (Parallel) پردازش کنید.

در اینجا از `ActionBlock` برای پردازش موازی (Parallel) داده‌ها استفاده می‌شود. این ابزار به شما اجازه می‌دهد پردازش‌ها را به طور موثر و موازی (Parallel) انجام دهید.

**کد مثال از Dataflow:**

```csharp
using System.Threading.Tasks;
using System.Threading.Tasks.Dataflow;

var block = new ActionBlock<int>(async number =>
{
    // انجام عملیات سنگین روی هر عدد به صورت موازی (Parallel)
    await Task.Delay(100); // شبیه‌سازی تاخیر
    Console.WriteLine($"Processing {number} on thread {Thread.CurrentThread.ManagedThreadId}");
});

for (int i = 0; i < 100; i++)
{
    block.Post(i);  // ارسال داده به بلوک برای پردازش
}

block.Complete();
await block.Completion;
```

#### تاثیرات استفاده از ActionBlock:

- **جریان داده موازی (Parallel):** از آنجا که هر عدد به صورت مستقل پردازش می‌شود، استفاده از `ActionBlock` می‌تواند به شما در انجام پردازش‌های موازی (Parallel) و مستقل کمک کند.

- **مدیریت بهتر منابع:** با استفاده از این ابزار می‌توانید بهتر از منابع پردازشی و حافظه استفاده کنید، چرا که به طور خودکار تعداد نخ‌ها و منابع را بهینه می‌کند.

### جمع‌بندی:

- **عبارت ValueTask:** استفاده از `ValueTask` در سناریوهای خاص می‌تواند به شما کمک کند تا از تخصیص حافظه اضافی جلوگیری کنید و عملکرد برنامه را بهبود بخشید.

- **سیستم Task Scheduler:** بهبودهای جدید در `Task Scheduler` به شما این امکان را می‌دهند که نخ‌ها را به شکل بهینه‌تر و با اولویت‌بندی مدیریت کنید.

- **برنامه‌نویسی موازی (Parallel Programming):** بهبودهای `Parallel.ForEach` و مدیریت خودکار نخ‌ها موجب پردازش سریع‌تر و بهینه‌تر داده‌ها می‌شود.

- **ابزار Dataflow:** ابزار `ActionBlock` برای پردازش داده‌ها به صورت موازی (Parallel) و مستقل از یکدیگر ارائه شده است که به شما کمک می‌کند پردازش‌های پیچیده‌تر و داده‌های بزرگ را مدیریت کنید.
